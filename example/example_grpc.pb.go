// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.3
// source: example/example.proto

package example

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EnabledServiceClient is the client API for EnabledService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnabledServiceClient interface {
	HandleHelloEvent(ctx context.Context, in *HandleHelloEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	HandleWorldEvent(ctx context.Context, in *HandleHelloEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type enabledServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEnabledServiceClient(cc grpc.ClientConnInterface) EnabledServiceClient {
	return &enabledServiceClient{cc}
}

func (c *enabledServiceClient) HandleHelloEvent(ctx context.Context, in *HandleHelloEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/sarama.EnabledService/HandleHelloEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enabledServiceClient) HandleWorldEvent(ctx context.Context, in *HandleHelloEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/sarama.EnabledService/HandleWorldEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnabledServiceServer is the server API for EnabledService service.
// All implementations must embed UnimplementedEnabledServiceServer
// for forward compatibility
type EnabledServiceServer interface {
	HandleHelloEvent(context.Context, *HandleHelloEventRequest) (*emptypb.Empty, error)
	HandleWorldEvent(context.Context, *HandleHelloEventRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEnabledServiceServer()
}

// UnimplementedEnabledServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEnabledServiceServer struct {
}

func (UnimplementedEnabledServiceServer) HandleHelloEvent(context.Context, *HandleHelloEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleHelloEvent not implemented")
}
func (UnimplementedEnabledServiceServer) HandleWorldEvent(context.Context, *HandleHelloEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleWorldEvent not implemented")
}
func (UnimplementedEnabledServiceServer) mustEmbedUnimplementedEnabledServiceServer() {}

// UnsafeEnabledServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnabledServiceServer will
// result in compilation errors.
type UnsafeEnabledServiceServer interface {
	mustEmbedUnimplementedEnabledServiceServer()
}

func RegisterEnabledServiceServer(s grpc.ServiceRegistrar, srv EnabledServiceServer) {
	s.RegisterService(&EnabledService_ServiceDesc, srv)
}

func _EnabledService_HandleHelloEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleHelloEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnabledServiceServer).HandleHelloEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sarama.EnabledService/HandleHelloEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnabledServiceServer).HandleHelloEvent(ctx, req.(*HandleHelloEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnabledService_HandleWorldEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleHelloEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnabledServiceServer).HandleWorldEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sarama.EnabledService/HandleWorldEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnabledServiceServer).HandleWorldEvent(ctx, req.(*HandleHelloEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnabledService_ServiceDesc is the grpc.ServiceDesc for EnabledService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnabledService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sarama.EnabledService",
	HandlerType: (*EnabledServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleHelloEvent",
			Handler:    _EnabledService_HandleHelloEvent_Handler,
		},
		{
			MethodName: "HandleWorldEvent",
			Handler:    _EnabledService_HandleWorldEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/example.proto",
}

// DisabledServiceClient is the client API for DisabledService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DisabledServiceClient interface {
	HandleExampleEvent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type disabledServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDisabledServiceClient(cc grpc.ClientConnInterface) DisabledServiceClient {
	return &disabledServiceClient{cc}
}

func (c *disabledServiceClient) HandleExampleEvent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/sarama.DisabledService/HandleExampleEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DisabledServiceServer is the server API for DisabledService service.
// All implementations must embed UnimplementedDisabledServiceServer
// for forward compatibility
type DisabledServiceServer interface {
	HandleExampleEvent(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedDisabledServiceServer()
}

// UnimplementedDisabledServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDisabledServiceServer struct {
}

func (UnimplementedDisabledServiceServer) HandleExampleEvent(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleExampleEvent not implemented")
}
func (UnimplementedDisabledServiceServer) mustEmbedUnimplementedDisabledServiceServer() {}

// UnsafeDisabledServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DisabledServiceServer will
// result in compilation errors.
type UnsafeDisabledServiceServer interface {
	mustEmbedUnimplementedDisabledServiceServer()
}

func RegisterDisabledServiceServer(s grpc.ServiceRegistrar, srv DisabledServiceServer) {
	s.RegisterService(&DisabledService_ServiceDesc, srv)
}

func _DisabledService_HandleExampleEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisabledServiceServer).HandleExampleEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sarama.DisabledService/HandleExampleEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisabledServiceServer).HandleExampleEvent(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// DisabledService_ServiceDesc is the grpc.ServiceDesc for DisabledService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DisabledService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sarama.DisabledService",
	HandlerType: (*DisabledServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleExampleEvent",
			Handler:    _DisabledService_HandleExampleEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/example.proto",
}

// UnspecifiedServiceClient is the client API for UnspecifiedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UnspecifiedServiceClient interface {
	HandleExampleEvent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type unspecifiedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUnspecifiedServiceClient(cc grpc.ClientConnInterface) UnspecifiedServiceClient {
	return &unspecifiedServiceClient{cc}
}

func (c *unspecifiedServiceClient) HandleExampleEvent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/sarama.UnspecifiedService/HandleExampleEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UnspecifiedServiceServer is the server API for UnspecifiedService service.
// All implementations must embed UnimplementedUnspecifiedServiceServer
// for forward compatibility
type UnspecifiedServiceServer interface {
	HandleExampleEvent(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedUnspecifiedServiceServer()
}

// UnimplementedUnspecifiedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUnspecifiedServiceServer struct {
}

func (UnimplementedUnspecifiedServiceServer) HandleExampleEvent(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleExampleEvent not implemented")
}
func (UnimplementedUnspecifiedServiceServer) mustEmbedUnimplementedUnspecifiedServiceServer() {}

// UnsafeUnspecifiedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UnspecifiedServiceServer will
// result in compilation errors.
type UnsafeUnspecifiedServiceServer interface {
	mustEmbedUnimplementedUnspecifiedServiceServer()
}

func RegisterUnspecifiedServiceServer(s grpc.ServiceRegistrar, srv UnspecifiedServiceServer) {
	s.RegisterService(&UnspecifiedService_ServiceDesc, srv)
}

func _UnspecifiedService_HandleExampleEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnspecifiedServiceServer).HandleExampleEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sarama.UnspecifiedService/HandleExampleEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnspecifiedServiceServer).HandleExampleEvent(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// UnspecifiedService_ServiceDesc is the grpc.ServiceDesc for UnspecifiedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UnspecifiedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sarama.UnspecifiedService",
	HandlerType: (*UnspecifiedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleExampleEvent",
			Handler:    _UnspecifiedService_HandleExampleEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "example/example.proto",
}
