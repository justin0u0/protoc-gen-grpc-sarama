// Code generated by protoc-gen-grpc-sarama. DO NOT EDIT.

package example

import (
	"errors"

	"github.com/Shopify/sarama"
	"google.golang.org/protobuf/proto"
	"github.com/justin0u0/protoc-gen-grpc-sarama/pkg/saramakit"
)

type EnabledServiceHandlers struct {
	*HandleHelloEventHandler
	*HandleWorldEventHandler
}

func NewEnabledServiceHandlers(server EnabledServiceServer, logger saramakit.Logger) *EnabledServiceHandlers {
	return &EnabledServiceHandlers{
		HandleHelloEventHandler: &HandleHelloEventHandler{
			server:      server,
			unmarshaler: &proto.UnmarshalOptions{},
			logger:      logger.With("HandlerName", "HandleHelloEventHandler"),
		},
		HandleWorldEventHandler: &HandleWorldEventHandler{
			server:      server,
			unmarshaler: &proto.UnmarshalOptions{},
			logger:      logger.With("HandlerName", "HandleWorldEventHandler"),
		},
	}
}

type HandleHelloEventHandler struct {
	server      EnabledServiceServer
	unmarshaler *proto.UnmarshalOptions
	logger      saramakit.Logger
}

var _ sarama.ConsumerGroupHandler = (*HandleHelloEventHandler)(nil)

func (h *HandleHelloEventHandler) Setup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleHelloEventHandler) Cleanup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleHelloEventHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var req HandleHelloEventRequest

		if err := h.unmarshaler.Unmarshal(msg.Value, &req); err != nil {
			// unretryable failure, skip and consume the message
			h.logger.Error("failed to unmarshal message", err)

			continue
		}

		if _, err := h.server.HandleHelloEvent(sess.Context(), &req); err != nil {
			var e saramakit.HandlerError

			if ok := errors.As(err, &e); ok && e.Retry {
				h.logger.Error("failed to handle the message and the error is retryable", err)

				return nil
			}
			h.logger.Error("failed to handle the message and the error is unretryable", err)
		}

		// mark message as completed
		sess.MarkMessage(msg, "")
	}

	return nil
}

type HandleWorldEventHandler struct {
	server      EnabledServiceServer
	unmarshaler *proto.UnmarshalOptions
	logger      saramakit.Logger
}

var _ sarama.ConsumerGroupHandler = (*HandleWorldEventHandler)(nil)

func (h *HandleWorldEventHandler) Setup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleWorldEventHandler) Cleanup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleWorldEventHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var req HandleHelloEventRequest

		if err := h.unmarshaler.Unmarshal(msg.Value, &req); err != nil {
			// unretryable failure, skip and consume the message
			h.logger.Error("failed to unmarshal message", err)

			continue
		}

		if _, err := h.server.HandleWorldEvent(sess.Context(), &req); err != nil {
			var e saramakit.HandlerError

			if ok := errors.As(err, &e); ok && e.Retry {
				h.logger.Error("failed to handle the message and the error is retryable", err)

				return nil
			}
			h.logger.Error("failed to handle the message and the error is unretryable", err)
		}

		// mark message as completed
		sess.MarkMessage(msg, "")
	}

	return nil
}
