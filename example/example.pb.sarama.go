// Code generated by protoc-gen-grpc-sarama. DO NOT EDIT.

package example

import (
	"errors"

	"github.com/Shopify/sarama"
	"google.golang.org/protobuf/proto"
	"github.com/justin0u0/protoc-gen-grpc-sarama/pkg/saramakit"
)

type EnabledServiceHandlers struct {
	*HandleHelloEventHandler
	*HandleWorldEventHandler
}

func NewEnabledServiceHandlers(server EnabledServiceServer) *EnabledServiceHandlers {
	return &EnabledServiceHandlers{
		HandleHelloEventHandler: &HandleHelloEventHandler{
			server:      server,
			unmarshaler: &proto.UnmarshalOptions{},
		},
		HandleWorldEventHandler: &HandleWorldEventHandler{
			server:      server,
			unmarshaler: &proto.UnmarshalOptions{},
		},
	}
}

type HandleHelloEventHandler struct {
	server      EnabledServiceServer
	unmarshaler *proto.UnmarshalOptions
}

var _ sarama.ConsumerGroupHandler = (*HandleHelloEventHandler)(nil)

func (h *HandleHelloEventHandler) Setup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleHelloEventHandler) Cleanup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleHelloEventHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var req HandleHelloEventRequest

		if err := h.unmarshaler.Unmarshal(msg.Value, &req); err != nil {
			// unretryable failed, log error then skip and consume the message
			continue
		}

		if _, err := h.server.HandleHelloEvent(sess.Context(), &req); err != nil {
			var e saramakit.HandlerError

			if ok := errors.As(err, &e); ok && e.Retry {
				// error returns by HandleHelloEvent and the error is retryable

				return nil
			}

			// error returns by HandleHelloEvent and the error is unretryable
		}

		// mark message as completed
		sess.MarkMessage(msg, "")
	}

	return nil
}

type HandleWorldEventHandler struct {
	server      EnabledServiceServer
	unmarshaler *proto.UnmarshalOptions
}

var _ sarama.ConsumerGroupHandler = (*HandleWorldEventHandler)(nil)

func (h *HandleWorldEventHandler) Setup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleWorldEventHandler) Cleanup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleWorldEventHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var req HandleHelloEventRequest

		if err := h.unmarshaler.Unmarshal(msg.Value, &req); err != nil {
			// unretryable failed, log error then skip and consume the message
			continue
		}

		if _, err := h.server.HandleWorldEvent(sess.Context(), &req); err != nil {
			var e saramakit.HandlerError

			if ok := errors.As(err, &e); ok && e.Retry {
				// error returns by HandleWorldEvent and the error is retryable

				return nil
			}

			// error returns by HandleWorldEvent and the error is unretryable
		}

		// mark message as completed
		sess.MarkMessage(msg, "")
	}

	return nil
}
