package internal

import (
	"bytes"
	"html/template"

	saramaproto "github.com/justin0u0/protoc-gen-grpc-sarama/proto"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type Generator struct{}

func (g *Generator) Generate(plugin *protogen.Plugin) error {
	if len(plugin.Files) == 0 {
		return nil
	}

	for _, f := range plugin.Files {
		if !f.Generate {
			continue
		}

		if err := g.generateFile(plugin, f); err != nil {
			return err
		}
	}

	return nil
}

func (gen *Generator) generateFile(plugin *protogen.Plugin, file *protogen.File) error {
	// Filter out services to be generated
	services := make([]*protogen.Service, 0)

	for _, service := range file.Services {
		options := service.Desc.Options().(*descriptorpb.ServiceOptions)

		if enabled := proto.GetExtension(options, saramaproto.E_Enabled).(bool); enabled {
			services = append(services, service)
			break
		}
	}

	if len(services) == 0 {
		return nil
	}

	// Generate code for the file
	filename := file.GeneratedFilenamePrefix + ".pb.sarama.go"

	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	if err := gen.genereateFileHeader(g, file); err != nil {
		return err
	}

	for _, service := range services {
		options := service.Desc.Options().(*descriptorpb.ServiceOptions)
		loggerEnabled := proto.GetExtension(options, saramaproto.E_LoggerEnabled).(bool)

		if err := gen.generateHandlers(g, service, loggerEnabled); err != nil {
			return err
		}
	}

	return nil
}

func (gen *Generator) genereateFileHeader(g *protogen.GeneratedFile, file *protogen.File) error {
	fileHeader := &FileHeader{
		Package: string(file.GoPackageName),
	}

	tmpl, err := template.New("file-header-template").Parse(`
// Code generated by protoc-gen-grpc-sarama. DO NOT EDIT.

package {{ .Package }}

import (
	"errors"

	"github.com/Shopify/sarama"
	"google.golang.org/protobuf/proto"
	"github.com/justin0u0/protoc-gen-grpc-sarama/pkg/saramakit"
)
`)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, fileHeader); err != nil {
		return err
	}

	g.P(string(buf.Bytes()))

	return nil
}

func (gen *Generator) generateHandlers(g *protogen.GeneratedFile, service *protogen.Service, loggerEnabled bool) error {
	handlers := &Handlers{
		Handlers:       make([]*Handler, 0, len(service.Methods)),
		Name:           service.GoName + "Handlers",
		GrpcServerName: service.GoName + "Server",
		LoggerEnabled:  loggerEnabled,
	}
	for _, method := range service.Methods {
		handlers.Handlers = append(handlers.Handlers, &Handler{
			Name:           method.GoName + "Handler",
			GrpcServerName: handlers.GrpcServerName,
			Method:         method.GoName,
			Input:          method.Input.GoIdent.GoName,
			LoggerEnabled:  loggerEnabled,
		})
	}

	tmpl, err := template.New("handlers-template").Parse(`
type {{ .Name }} struct {
{{ range .Handlers }}
	*{{ .Name -}}
{{ end }}
}

{{- if .LoggerEnabled }}
func New{{ .Name }}(server {{ .GrpcServerName }}, logger saramakit.Logger) *{{ .Name }} {
{{- else }}
func New{{ .Name }}(server {{ .GrpcServerName }}) *{{ .Name }} {
{{- end }}
	return &{{ .Name }}{
{{- range .Handlers }}
		{{ .Name }}: &{{ .Name }}{
			server:      server,
			unmarshaler: &proto.UnmarshalOptions{},
			{{- if .LoggerEnabled }}
			logger:      logger.With("HandlerName", "{{ .Name }}"),
			{{- end }}
		},
{{- end }}
	}
}
`)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, handlers); err != nil {
		return err
	}

	g.P(string(buf.Bytes()))

	for _, handler := range handlers.Handlers {
		if err := gen.generateHandler(g, handler); err != nil {
			return err
		}
	}

	return nil
}

func (gen *Generator) generateHandler(g *protogen.GeneratedFile, handler *Handler) error {
	tmpl, err := template.New("handler-template").Parse(`
type {{.Name}} struct {
	server      {{.GrpcServerName}}
	unmarshaler *proto.UnmarshalOptions
{{- if .LoggerEnabled }}
	logger      saramakit.Logger
{{- end }}
}

var _ sarama.ConsumerGroupHandler = (*{{ .Name }})(nil)

func (h *{{ .Name }}) Setup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *{{ .Name }}) Cleanup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *{{ .Name }}) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var req {{ .Input }}

		if err := h.unmarshaler.Unmarshal(msg.Value, &req); err != nil {
			// unretryable failure, skip and consume the message
{{- if .LoggerEnabled }}
			h.logger.Error("failed to unmarshal message", err)
{{- end }}

			continue
		}

		if _, err := h.server.{{ .Method }}(sess.Context(), &req); err != nil {
			var e saramakit.HandlerError

			if ok := errors.As(err, &e); ok && e.Retry {
{{- if .LoggerEnabled }}
				h.logger.Error("failed to handle the message and the error is retryable", err)
{{- end }}

				return nil
			}

{{- if .LoggerEnabled }}
			h.logger.Error("failed to handle the message and the error is unretryable", err)
{{- end }}
		}

		// mark message as completed
		sess.MarkMessage(msg, "")
	}

	return nil
}
`)

	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, handler); err != nil {
		return err
	}

	g.P(string(buf.Bytes()))

	return nil
}
