package internal

import (
	"bytes"
	"html/template"

	saramaproto "github.com/justin0u0/protoc-gen-grpc-sarama/proto"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type Generator struct{}

func (g *Generator) Generate(plugin *protogen.Plugin) error {
	if len(plugin.Files) == 0 {
		return nil
	}

	for _, f := range plugin.Files {
		if !f.Generate {
			continue
		}

		if err := g.generateFile(plugin, f); err != nil {
			return err
		}
	}

	return nil
}

func (gen *Generator) generateFile(plugin *protogen.Plugin, file *protogen.File) error {
	// Filter out services to be generated
	services := make([]*protogen.Service, 0)

	for _, service := range file.Services {
		options := service.Desc.Options().(*descriptorpb.ServiceOptions)

		if enabled := proto.GetExtension(options, saramaproto.E_Enabled).(bool); enabled {
			services = append(services, service)
			break
		}
	}

	if len(services) == 0 {
		return nil
	}

	// Generate code for the file
	filename := file.GeneratedFilenamePrefix + ".pb.sarama.go"

	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-grpc-sarama. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P(`
import (
	"errors"

	"github.com/Shopify/sarama"
	"google.golang.org/protobuf/proto"
	"github.com/justin0u0/protoc-gen-grpc-sarama/pkg/saramakit"
)

`)

	for _, service := range services {
		if err := gen.generateHandlers(g, service); err != nil {
			return err
		}
	}

	return nil
}

func (gen *Generator) generateHandlers(g *protogen.GeneratedFile, service *protogen.Service) error {
	handlers := &Handlers{
		Handlers:       make([]*Handler, 0, len(service.Methods)),
		Name:           service.GoName + "Handlers",
		GrpcServerName: service.GoName + "Server",
	}
	for _, method := range service.Methods {
		handlers.Handlers = append(handlers.Handlers, &Handler{
			Name:           method.GoName + "Handler",
			GrpcServerName: handlers.GrpcServerName,
			Method:         method.GoName,
			Input:          method.Input.GoIdent.GoName,
		})
	}

	tmpl, err := template.New("handlers-template").Parse(`
type {{ .Name }} struct {
{{ range .Handlers }}
	*{{ .Name -}}
{{ end }}
}

func New{{ .Name }}(server {{.GrpcServerName}}) *{{ .Name }} {
	return &{{ .Name }}{
{{- range .Handlers }}
		{{ .Name }}: &{{ .Name }}{
			server:      server,
			unmarshaler: &proto.UnmarshalOptions{},
		},
{{- end }}
	}
}
`)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, handlers); err != nil {
		return err
	}

	g.P(string(buf.Bytes()))

	for _, handler := range handlers.Handlers {
		if err := gen.generateHandler(g, handler); err != nil {
			return err
		}
	}

	return nil
}

func (gen *Generator) generateHandler(g *protogen.GeneratedFile, handler *Handler) error {
	tmpl, err := template.New("handler-template").Parse(`
type {{.Name}} struct {
	server      {{.GrpcServerName}}
	unmarshaler *proto.UnmarshalOptions
}

var _ sarama.ConsumerGroupHandler = (*{{ .Name }})(nil)

func (h *{{ .Name }}) Setup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *{{ .Name }}) Cleanup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *{{ .Name }}) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var req {{ .Input }}

		if err := h.unmarshaler.Unmarshal(msg.Value, &req); err != nil {
			// unretryable failed, log error then skip and consume the message
			continue
		}

		if _, err := h.server.{{ .Method }}(sess.Context(), &req); err != nil {
			var e saramakit.HandlerError

			if ok := errors.As(err, &e); ok && e.Retry {
				// error returns by {{ .Method }} and the error is retryable

				return nil
			}

			// error returns by {{ .Method }} and the error is unretryable
		}

		// mark message as completed
		sess.MarkMessage(msg, "")
	}

	return nil
}
`)

	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, handler); err != nil {
		return err
	}

	g.P(string(buf.Bytes()))

	return nil
}
